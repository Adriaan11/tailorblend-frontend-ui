@page "/configuration"
@using BlazorConsultant.Models
@inject IInstructionService InstructionService
@inject IJSRuntime JSRuntime
@inject ILogger<Configuration> Logger

<PageTitle>Configuration - TailorBlend AI Consultant</PageTitle>

<section class="tb-card tb-card--flat" style="margin-bottom: var(--tb-space-lg);">
    <div class="tb-stack" style="gap: var(--tb-space);">
        <div style="display: flex; align-items: center; gap: var(--tb-space-16); margin-bottom: var(--tb-space-12);">
            <div class="tb-icon-container tb-icon-container--accent">
                <TbIcon Icon="gear" Size="lg" Color="accent" Style="font-size: 1.5rem;" />
            </div>
            <div>
                <div style="display: flex; align-items: center; gap: var(--tb-space-8); margin-bottom: var(--tb-space-4);">
                    <div class="tb-badge">
                        <TbIcon Icon="sliders" Size="sm" />
                        Configuration
                    </div>
                </div>
                <TbText Typo="overline" Class="tb-muted">Agent configuration</TbText>
            </div>
        </div>
        <TbText Typo="h5" Style="font-weight:700;">Fine-tune how TailorBlend consults</TbText>
        <TbText Typo="body2" Class="tb-muted">
            Update the system instructions that guide tone, safety checks, and recommendation frameworks. Changes apply to the very next conversation.
        </TbText>

        <div class="tb-divider" style="margin: var(--tb-space-sm) 0;"></div>

        <div class="tb-stack" style="gap: var(--tb-space-sm);">
            <div style="display: flex; align-items: center; gap: var(--tb-space-8);">
                <TbIcon Icon="pen" Size="sm" />
                <TbText Typo="subtitle2" Style="font-weight:600;">Editing Mode</TbText>
            </div>
            <TbRadioGroup Value="@editMode"
                          ValueChanged="@OnModeChanged"
                          Options="@(new List<string> { "granular", "raw" })"
                          OptionLabels="@(new List<string> { "Granular Sections - Edit structured sections separately", "Raw Instructions - Paste your own complete system prompt" })" />
        </div>
    </div>
</section>

@if (isLoading)
{
    <div class="tb-stack" style="align-items:center; gap: var(--tb-space); padding: var(--tb-space-lg);">
        <TbLoadingSpinner Size="lg" Variant="circular" Color="success" />
        <TbText Typo="body1" Class="tb-muted">Loading instruction sections...</TbText>
    </div>
}
else if (sections.Count == 0)
{
    <div class="tb-empty-state">
        <div class="tb-icon-container tb-icon-container--warning" style="margin: 0 auto var(--tb-space-16);">
            <TbIcon Icon="exclamation-triangle" Size="lg" Color="warning" Style="font-size: 1.5rem;" />
        </div>
        <TbText Typo="subtitle1" Style="font-weight:600;">No instruction sections available</TbText>
        <TbText Typo="body2" Class="tb-muted">Refresh the page or reset to defaults to restore the standard TailorBlend playbook.</TbText>
        <TbButton Variant="filled" Color="primary" @onclick="ResetToDefaults">Restore defaults</TbButton>
    </div>
}
else
{
    if (!string.IsNullOrEmpty(statusMessage))
    {
        <TbAlert Severity="@(statusClass == "success" ? "success" : "error")"
                 Message="@statusMessage"
                 Closeable="true" />
    }

    @if (editMode == "raw")
    {
        <!-- Raw Instructions Mode -->
        <div class="tb-card tb-card--flat">
            <div class="tb-stack" style="gap: var(--tb-space);">
                <div class="tb-stack" style="gap: var(--tb-space-sm);">
                    <TbText Typo="subtitle1" Style="font-weight:600;">Raw System Instructions</TbText>
                    <TbText Typo="caption" Class="tb-muted">
                        Paste your complete system prompt here. This will replace all granular sections.
                    </TbText>
                </div>

                <textarea class="tb-textarea"
                          @bind="rawInstructions"
                          @bind:event="oninput"
                          placeholder="Paste your complete system instructions here..."
                          style="min-height: 500px; font-family: var(--tb-font-mono); font-size: 0.9rem;"></textarea>

                <div class="tb-stack tb-stack--row" style="justify-content: space-between;">
                    <TbText Typo="caption" Class="tb-muted">Character count: @(rawInstructions?.Length.ToString("N0") ?? "0")</TbText>
                    <TbText Typo="caption" Class="tb-muted">Last updated: @DateTime.Now.ToString("HH:mm")</TbText>
                </div>

                <div class="tb-divider"></div>

                <div class="tb-stack tb-stack--row" style="justify-content:flex-end;">
                    <TbButton Variant="outlined"
                              Color="secondary"
                              @onclick="ResetToDefaults"
                              Disabled="@isSaving"
                              StartIcon="rotate-left">
                        Reset to defaults
                    </TbButton>
                    <TbButton Variant="filled"
                              Color="primary"
                              @onclick="ApplyRawChanges"
                              Disabled="@isSaving"
                              StartIcon="@(isSaving ? null : "check-circle")">
                        @if (isSaving)
                        {
                            <TbLoadingSpinner Size="sm" Variant="circular" />
                            <span>Saving</span>
                        }
                        else
                        {
                            <span>Apply changes</span>
                        }
                    </TbButton>
                </div>
            </div>
        </div>
    }
    else
    {
        <!-- Granular Sections Mode -->
        <div class="tb-editor-shell">
        <nav class="tb-editor-nav">
            @foreach (var section in sections)
            {
                var isActive = activeSection == section;
                <TbButton Variant="@(isActive ? "filled" : "text")"
                          Color="primary"
                          @onclick="() => SelectSection(section)"
                          Style="width: 100%; justify-content: flex-start;">
                    <TbText Typo="subtitle2" Style="font-weight:600;">@(section.Name)</TbText>
                    <TbText Typo="caption" Class="tb-muted">@(section.LineCount) lines</TbText>
                </TbButton>
            }
        </nav>

        <div class="tb-editor-panel">
            <div class="tb-stack" style="gap: var(--tb-space-sm);">
                <TbText Typo="subtitle1" Style="font-weight:600;">@activeSection?.Name</TbText>
                <TbText Typo="caption" Class="tb-muted">
                    Edit instructions to steer the AI's approach for this step of the consultation.
                </TbText>
            </div>

            <textarea class="tb-textarea"
                      @bind="activeSection!.Content"
                      @bind:event="oninput"
                      placeholder="Compose refined instructions that reflect your operating procedures."></textarea>

            <div class="tb-stack tb-stack--row" style="justify-content: space-between;">
                <TbText Typo="caption" Class="tb-muted">Character count: @((activeSection?.Content?.Length ?? 0).ToString("N0"))</TbText>
                <TbText Typo="caption" Class="tb-muted">Last updated: @DateTime.Now.ToString("HH:mm")</TbText>
            </div>

            <div class="tb-divider"></div>

            <div class="tb-stack tb-stack--row" style="justify-content:flex-end;">
                <TbButton Variant="outlined"
                          Color="secondary"
                          @onclick="ResetToDefaults"
                          Disabled="@isSaving"
                          StartIcon="rotate-left">
                    Reset to defaults
                </TbButton>
                <TbButton Variant="filled"
                          Color="primary"
                          @onclick="ApplyChanges"
                          Disabled="@isSaving"
                          StartIcon="@(isSaving ? null : "check-circle")">
                    @if (isSaving)
                    {
                        <TbLoadingSpinner Size="sm" Variant="circular" />
                        <span>Saving</span>
                    }
                    else
                    {
                        <span>Apply changes</span>
                    }
                </TbButton>
            </div>
        </div>
        </div>
    }
}

@code {
    private List<InstructionSection> sections = new();
    private InstructionSection? activeSection;
    private bool isLoading = true;
    private bool isSaving;
    private string statusMessage = string.Empty;
    private string statusClass = string.Empty;
    private string editMode = "granular"; // "granular" or "raw"
    private string rawInstructions = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        // Load saved editing mode from localStorage
        try
        {
            var savedMode = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "tb_editMode");
            if (!string.IsNullOrEmpty(savedMode) && (savedMode == "granular" || savedMode == "raw"))
            {
                editMode = savedMode;
                Logger.LogInformation("Loaded editing mode from localStorage: {Mode}", editMode);
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load editing mode from localStorage");
        }

        await LoadSections();

        // Load raw instructions if in raw mode
        if (editMode == "raw")
        {
            try
            {
                rawInstructions = await InstructionService.GetFullTextAsync().ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to load raw instructions");
            }
        }
    }

    private async Task OnModeChanged(string newMode)
    {
        editMode = newMode;

        // Save to localStorage
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "tb_editMode", newMode);
            Logger.LogInformation("Saved editing mode to localStorage: {Mode}", newMode);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to save editing mode to localStorage");
        }

        // Convert between modes
        if (newMode == "raw")
        {
            if (sections.Any())
            {
                // Convert sections to raw text
                rawInstructions = string.Join("\n\n", sections.Select(s => $"{s.Name}\n{s.Content}"));
            }
            else if (string.IsNullOrEmpty(rawInstructions))
            {
                // Load from API if we don't have anything yet
                try
                {
                    rawInstructions = await InstructionService.GetFullTextAsync().ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    Logger.LogWarning(ex, "Failed to load raw instructions");
                }
            }
        }
        else if (newMode == "granular" && !string.IsNullOrEmpty(rawInstructions))
        {
            // User switched back to granular - keep existing sections
            // (they can always reset to defaults if needed)
        }

        // Use InvokeAsync to marshal StateHasChanged back to the Dispatcher thread
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadSections()
    {
        isLoading = true;
        try
        {
            sections = await InstructionService.GetSectionsAsync().ConfigureAwait(false);
            activeSection = sections.FirstOrDefault();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load instruction sections");
            statusMessage = "Failed to load instructions";
            statusClass = "error";
        }
        finally
        {
            isLoading = false;
            // Use InvokeAsync to marshal StateHasChanged back to the Dispatcher thread
            await InvokeAsync(StateHasChanged);
        }
    }

    private void SelectSection(InstructionSection section)
    {
        activeSection = section;
    }

    private async Task ApplyChanges()
    {
        if (isSaving)
            return;

        isSaving = true;
        statusMessage = string.Empty;

        try
        {
            var success = await InstructionService.UpdateSectionsAsync(sections).ConfigureAwait(false);
            if (success)
            {
                statusMessage = "Changes applied. The next chat will follow your updated playbook.";
                statusClass = "success";
            }
            else
            {
                statusMessage = "Failed to apply changes. Please try again.";
                statusClass = "error";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update instruction sections");
            statusMessage = $"Error: {ex.Message}";
            statusClass = "error";
        }
        finally
        {
            isSaving = false;
            // Use InvokeAsync to marshal StateHasChanged back to the Dispatcher thread
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ApplyRawChanges()
    {
        if (isSaving)
            return;

        isSaving = true;
        statusMessage = string.Empty;

        try
        {
            // For raw mode, we send the entire instructions as-is
            // The backend will use this as custom_instructions parameter
            var success = await InstructionService.UpdateRawInstructionsAsync(rawInstructions).ConfigureAwait(false);
            if (success)
            {
                statusMessage = "Raw instructions applied. The next chat will use your custom prompt.";
                statusClass = "success";
            }
            else
            {
                statusMessage = "Failed to apply changes. Please try again.";
                statusClass = "error";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update raw instructions");
            statusMessage = $"Error: {ex.Message}";
            statusClass = "error";
        }
        finally
        {
            isSaving = false;
            // Use InvokeAsync to marshal StateHasChanged back to the Dispatcher thread
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ResetToDefaults()
    {
        if (isSaving)
            return;

        isSaving = true;
        statusMessage = string.Empty;

        try
        {
            sections = await InstructionService.GetDefaultSectionsAsync().ConfigureAwait(false);
            activeSection = sections.FirstOrDefault();

            // Also reset raw instructions to default
            rawInstructions = string.Join("\n\n", sections.Select(s => $"{s.Name}\n{s.Content}"));

            statusMessage = "Reset to TailorBlend defaults.";
            statusClass = "success";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to reset instruction sections to defaults");
            statusMessage = $"Error: {ex.Message}";
            statusClass = "error";
        }
        finally
        {
            isSaving = false;
            // Use InvokeAsync to marshal StateHasChanged back to the Dispatcher thread
            await InvokeAsync(StateHasChanged);
        }
    }
}
