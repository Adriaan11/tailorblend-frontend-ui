@using BlazorConsultant.Models
@using Markdig
@implements IDisposable

<div class="tb-message @(Message.Role == "user" ? "user" : "assistant")">
    <div class="tb-message__meta">
        <div class="tb-message__author">
            <MudIcon Icon="@(Message.Role == "user" ? Icons.Material.Filled.Person : Icons.Material.Filled.LocalFlorist)" />
            <span>@(Message.Role == "user" ? "You" : "TailorBlend AI")</span>
        </div>
        <span title="@Message.Timestamp.ToString("yyyy-MM-dd HH:mm:ss")">@GetRelativeTime(Message.Timestamp)</span>
    </div>

    @if (Message.Attachments != null && Message.Attachments.Count > 0)
    {
        <div style="margin-top: 8px;">
            <FilePreviewComponent Attachments="@Message.Attachments" ShowRemoveButton="false" />
        </div>
    }

    <div class="tb-message__body">
        @if (Message.Role == "assistant" && TypewriterEnabled && _isTyping)
        {
            @((MarkupString)_displayedHtml)
        }
        else
        {
            @((MarkupString)FormatMessage(Message.Content))
        }
    </div>

    <div class="tb-message__actions">
        <button class="tb-action-btn" title="Copy message" aria-label="Copy message" @onclick="CopyMessage">
            <MudIcon Icon="@Icons.Material.Filled.ContentCopy" Size="Size.Small" />
        </button>
        @if (Message.Role == "assistant")
        {
            <button class="tb-action-btn" title="Regenerate response" aria-label="Regenerate response">
                <MudIcon Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" />
            </button>
        }
        <button class="tb-action-btn" title="Share" aria-label="Share message">
            <MudIcon Icon="@Icons.Material.Filled.Share" Size="Size.Small" />
        </button>
    </div>
</div>

@inject IJSRuntime JS

@code {
    [Parameter]
    public ChatMessage Message { get; set; } = new();

    // ✅ TYPEWRITER CONTROL: Controlled by parent component (Chat.razor) via parameter
    // Defaults to enabled if parent doesn't specify
    [Parameter]
    public bool TypewriterEnabled { get; set; } = true;

    // ✅ PERFORMANCE: Static shared markdown pipeline (created once, reused by all instances)
    // Previously: Pipeline was rebuilt on EVERY render (expensive regex compilation)
    private static readonly MarkdownPipeline _sharedPipeline =
        new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();

    // ✅ PERFORMANCE: Cache fields to prevent redundant markdown parsing
    private string? _lastContent;
    private string? _cachedHtml;

    // ✅ TYPEWRITER: State management for character-by-character reveal
    private bool _isTyping = false;              // Is typewriter currently active?
    private string _displayedHtml = "";          // HTML revealed so far
    private int _typewriterIndex = 0;            // Current character position
    private Timer? _typewriterTimer;             // Interval timer for animation
    private string _fullContentSnapshot = "";    // Detect content changes

    // ✅ PERFORMANCE: Override ShouldRender to prevent unnecessary re-renders
    // Only re-render when content actually changes OR typewriter is animating
    protected override bool ShouldRender()
    {
        // Always render during typewriter animation
        if (_isTyping)
            return true;

        bool contentChanged = Message.Content != _lastContent;

        if (contentChanged)
        {
            _lastContent = Message.Content;
            return true;
        }

        return false; // Block unnecessary re-renders
    }

    // ✅ TYPEWRITER: Detect new messages and trigger typewriter animation
    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // DEBUG: Log typewriter state
        Console.WriteLine($"[ChatMessageComponent] TypewriterEnabled={TypewriterEnabled}, Role={Message.Role}, ContentLength={Message.Content?.Length ?? 0}");

        // Only apply typewriter to assistant messages when enabled
        if (!TypewriterEnabled || Message.Role != "assistant")
        {
            Console.WriteLine($"[ChatMessageComponent] Skipping typewriter (Enabled={TypewriterEnabled}, Role={Message.Role})");
            return;
        }

        // Detect new content (not already seen)
        if (!string.IsNullOrEmpty(Message.Content) &&
            Message.Content != _fullContentSnapshot)
        {
            Console.WriteLine($"[ChatMessageComponent] Starting typewriter for new content ({Message.Content.Length} chars)");
            _fullContentSnapshot = Message.Content;
            StartTypewriter();
        }
    }

    private string GetRelativeTime(DateTime timestamp)
    {
        var diff = DateTime.Now - timestamp;

        if (diff.TotalSeconds < 30) return "Just now";
        if (diff.TotalMinutes < 1) return $"{(int)diff.TotalSeconds}s ago";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}h ago";

        return timestamp.ToString("MMM d, HH:mm");
    }

    private async Task CopyMessage()
    {
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", Message.Content);
        }
        catch
        {
            // Silently handle copy failures
        }
    }

    // ✅ TYPEWRITER: Start character-by-character reveal animation
    private void StartTypewriter()
    {
        // Stop any existing timer
        _typewriterTimer?.Dispose();

        // Parse markdown once (reuse cached result if available)
        _cachedHtml = Markdown.ToHtml(Message.Content, _sharedPipeline);
        _lastContent = Message.Content;

        // Reset typewriter state
        _displayedHtml = "";
        _typewriterIndex = 0;
        _isTyping = true;

        // Start timer: 15ms intervals, 2 chars per tick = ~133 chars/sec (medium pace)
        _typewriterTimer = new Timer(_ =>
        {
            InvokeAsync(() =>
            {
                if (_typewriterIndex >= _cachedHtml.Length)
                {
                    // Typing complete - show full message
                    _displayedHtml = _cachedHtml;
                    _isTyping = false;
                    _typewriterTimer?.Dispose();
                    StateHasChanged();
                    return;
                }

                // Reveal next 2 characters
                _typewriterIndex += 2;
                _displayedHtml = _cachedHtml.Substring(0,
                    Math.Min(_typewriterIndex, _cachedHtml.Length));

                StateHasChanged();
            });
        }, null, 0, 15);  // 0ms initial delay, 15ms interval
    }

    // ✅ PERFORMANCE: Cached markdown parsing with shared pipeline
    private string FormatMessage(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return string.Empty;

        // Cache hit - reuse previously parsed HTML
        if (content == _lastContent && _cachedHtml != null)
            return _cachedHtml;

        // Cache miss - parse markdown and cache result
        _cachedHtml = Markdown.ToHtml(content, _sharedPipeline);
        _lastContent = content;

        return _cachedHtml;
    }

    // ✅ TYPEWRITER: Clean up timer on component disposal to prevent memory leaks
    public void Dispose()
    {
        _typewriterTimer?.Dispose();
    }
}
