@using BlazorConsultant.Models
@using Markdig

<div class="tb-message @(Message.Role == "user" ? "user" : "assistant")">
    <div class="tb-message__meta">
        <div class="tb-message__author">
            <MudIcon Icon="@(Message.Role == "user" ? Icons.Material.Filled.Person : Icons.Material.Filled.LocalFlorist)" />
            <span>@(Message.Role == "user" ? "You" : "TailorBlend AI")</span>
        </div>
        <span title="@Message.Timestamp.ToString("yyyy-MM-dd HH:mm:ss")">@GetRelativeTime(Message.Timestamp)</span>
    </div>

    @if (Message.Attachments != null && Message.Attachments.Count > 0)
    {
        <div style="margin-top: 8px;">
            <FilePreviewComponent Attachments="@Message.Attachments" ShowRemoveButton="false" />
        </div>
    }

    <div class="tb-message__body">
        @((MarkupString)FormatMessage(Message.Content))
    </div>

    <div class="tb-message__actions">
        <button class="tb-action-btn" title="Copy message" aria-label="Copy message" @onclick="CopyMessage">
            <MudIcon Icon="@Icons.Material.Filled.ContentCopy" Size="Size.Small" />
        </button>
        @if (Message.Role == "assistant")
        {
            <button class="tb-action-btn" title="Regenerate response" aria-label="Regenerate response">
                <MudIcon Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" />
            </button>
        }
        <button class="tb-action-btn" title="Share" aria-label="Share message">
            <MudIcon Icon="@Icons.Material.Filled.Share" Size="Size.Small" />
        </button>
    </div>
</div>

@inject IJSRuntime JS

@code {
    [Parameter]
    public ChatMessage Message { get; set; } = new();

    // ✅ PERFORMANCE: Static shared markdown pipeline (created once, reused by all instances)
    // Previously: Pipeline was rebuilt on EVERY render (expensive regex compilation)
    private static readonly MarkdownPipeline _sharedPipeline =
        new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();

    // ✅ PERFORMANCE: Cache fields to prevent redundant markdown parsing
    private string? _lastContent;
    private string? _cachedHtml;

    // ✅ PERFORMANCE: Override ShouldRender to prevent unnecessary re-renders
    // Only re-render when content actually changes
    protected override bool ShouldRender()
    {
        bool contentChanged = Message.Content != _lastContent;

        if (contentChanged)
        {
            _lastContent = Message.Content;
            return true;
        }

        return false; // Block unnecessary re-renders
    }

    private string GetRelativeTime(DateTime timestamp)
    {
        var diff = DateTime.Now - timestamp;

        if (diff.TotalSeconds < 30) return "Just now";
        if (diff.TotalMinutes < 1) return $"{(int)diff.TotalSeconds}s ago";
        if (diff.TotalMinutes < 60) return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24) return $"{(int)diff.TotalHours}h ago";

        return timestamp.ToString("MMM d, HH:mm");
    }

    private async Task CopyMessage()
    {
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", Message.Content);
        }
        catch
        {
            // Silently handle copy failures
        }
    }

    // ✅ PERFORMANCE: Cached markdown parsing with shared pipeline
    private string FormatMessage(string content)
    {
        if (string.IsNullOrWhiteSpace(content))
            return string.Empty;

        // Cache hit - reuse previously parsed HTML
        if (content == _lastContent && _cachedHtml != null)
            return _cachedHtml;

        // Cache miss - parse markdown and cache result
        _cachedHtml = Markdown.ToHtml(content, _sharedPipeline);
        _lastContent = content;

        return _cachedHtml;
    }
}
